

## 🧠 Intuition  
처음엔 스택으로 풀려고 했다.  
- 문자열을 앞에서 순서대로 넣고,  
- 뒤에서 pop하면서 거꾸로된 문자열을 만들고  
- 원래 문자열이랑 비교하려 했음.

근데 막상 보니까  
- `공백`, `콤마`, `콜론`, `"` 같은 걸 다 제거해야 하고  
- 대문자 → 소문자 통일도 해야 해서 너무 복잡해졌음  
- 특히 정규표현식을 몰라서 전처리를 못 하겠어서 결국 못 풀었고,  
**solution을 보고 나서야 정규표현식 + 투 포인터 방식이 훨씬 간단하다는 걸 알게 됨**

---

## 🔍 Approach  
1. 문자열을 **전부 소문자로 변환**
2. 정규표현식 `/[^a-z0-9]/g`를 써서 **알파벳과 숫자 이외의 모든 문자 제거**
3. 투 포인터 방식으로, 문자열 양 끝에서부터 비교하며 **회문인지 확인**

---

## ⏱ Complexity

- **Time complexity:** $$O(n)$$  
  전처리와 투 포인터 모두 문자열 한 번만 순회

- **Space complexity:** $$O(n)$$  
  전처리된 문자열이 새로운 문자열로 만들어지기 때문

---

## 💻 Code

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    // 1. 소문자로 만들고 알파벳+숫자 외 제거
    s = s.toLowerCase().replace(/[^a-z0-9]/g, "");

    // 2. 투 포인터 비교
    let left = 0;
    let right = s.length - 1;

    while (left < right) {
        if (s[left] !== s[right]) return false;
        left++;
        right--;
    }

    return true;
};
```

---

## ✍️ 회고
- 정규표현식을 몰라서 전처리 자체를 못 했던 게 가장 큰 이유였다.
- `"[^a-z0-9]"`처럼, 알파벳과 숫자를 제외한 모든 문자를 제거하는 패턴은  
  자주 쓰일 수 있으므로 반드시 외워두자.
- 스택으로도 접근할 수는 있겠지만, **이 문제는 전형적인 투 포인터 문제**였다.
- 투 포인터 패턴은 배열, 문자열, 연결 리스트 등에서 자주 쓰이니 익숙해져야겠다.

